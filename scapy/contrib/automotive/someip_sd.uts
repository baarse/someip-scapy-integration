##########
##########

+ SD Entry Service

=load module
load_contrib("automotive.someip_sd")
sd = SD()
p = SDEntry_Service()

= packet length

assert(len(binascii.hexlify(str(p))) / 2 == SDEntry_Service.OVERALL_LEN)

= fields setting
p.type = SDEntry_Service.TYPE_SRV_OFFERSERVICE
p.index_1 = 0x11
p.index_2 = 0x22
p.srv_id = 0x3333
p.inst_id = 0x4444
p.major_ver = 0x55
p.ttl = 0x666666
p.minor_ver = 0xdeadbeef

p_str = binascii.hexlify(str(p))
bin_str = "011122003333444455666666deadbeef"
assert(p_str == bin_str)

= fields setting : N_OPT
# value above 4 bits, serialized packet should feature  0x1 and 0x2
del (p)
p = SDEntry_Service()
p.n_opt_1 = 0xf1
p.n_opt_2 = 0xf2
p_str = binascii.hexlify(str(p))
bin_str = "00" * 3 + "12" + "00" * 12
assert(p_str == bin_str)
assert(len(p_str) / 2 == SDEntry_Service.OVERALL_LEN)

= Payload guess
p_entry_srv = SDEntry_Service()
assert(SDEntry_Service().guess_payload_class(str(p_entry_srv)) == SDEntry_Service)

+ SD Entry Eventgroup

= packet length
p = SDEntry_EventGroup()
assert(len(binascii.hexlify(str(p))) / 2 == SDEntry_EventGroup.OVERALL_LEN)

# = fields setting
# p.index_1 = 0x11
# p.index_2 = 0x22
# p.srv_id = 0x3333
# p.inst_id = 0x4444
# p.major_ver = 0x55
# p.ttl = 0x666666
# p.cnt = 0x7
# p.eventgroup_id = 0x8888
#
# p_str = binascii.hexlify(str(p))
# bin_str = "06112200333344445566666600078888"
# assert(p_str == bin_str)
#
# = Payload guess
# p_entry = sd._SDEntry()
# p_entry_evtgrp = sd.SDEntry_EventGroup()
#
# assert(p_entry.guess_payload_class(str(p_entry_evtgrp)) == sd.SDEntry_EventGroup)
#
# +SD Option Config
# p = sd.SDOption_Config()
#
# = pkg type
# assert(p.type == sd._SDOption.CFG_TYPE)
#
# = length without payload
# assert(len(binascii.hexlify(str(p))) / 2 == sd._SDOption.CFG_OVERALL_LEN)
#
# = add payload and check length
# p.cfg_str = "5abc=x7def=1230"
# assert(binascii.hexlify(str(p)) == "00100100" + binascii.hexlify("5abc=x7def=1230"))
#
# = Payload guess
# p_option = sd._SDOption()
# assert(p_option.guess_payload_class(str(p)) == sd.SDOption_Config)
#
# + SD Option Load Balance
# p = sd.SDOption_LoadBalance()
#
# = pkg type & lengths (static and overall)
# assert(p.type == sd._SDOption.LOADBALANCE_TYPE)
# assert(p.len == sd._SDOption.LOADBALANCE_LEN)
# assert(len(binascii.hexlify(str(p))) / 2 == sd._SDOption.LOADBALANCE_OVERALL_LEN)
#
# = Payload guess
# p_option = sd._SDOption()
# assert(p_option.guess_payload_class(str(p)) == sd.SDOption_LoadBalance)
#
# +SD Option IP4 Endpoint
# p = sd.SDOption_IP4_EndPoint()
#
# = pkg type & length
# assert(p.type == sd._SDOption.IP4_ENDPOINT_TYPE)
# assert(p.len == sd._SDOption.IP4_ENDPOINT_LEN)
#
# = Payload guess
# p_option = sd._SDOption()
# assert(p_option.guess_payload_class(str(p)) == sd.SDOption_IP4_EndPoint)
#
# +SD Option IP4 Multicast
# p = sd.SDOption_IP4_Multicast()
#
# = pkg type & length
# assert(p.type == sd._SDOption.IP4_MCAST_TYPE)
# assert(p.len == sd._SDOption.IP4_MCAST_LEN)
#
# = Payload guess
# p_option = sd._SDOption()
# assert(p_option.guess_payload_class(str(p)) == sd.SDOption_IP4_Multicast)
#
# +SD OPTION IP4 SD EndPoint
# p = sd.SDOption_IP4_SD_EndPoint()
#
# = pkg type & length
# assert(p.type == sd._SDOption.IP4_SDENDPOINT_TYPE)
# assert(p.len == sd._SDOption.IP4_SDENDPOINT_LEN)
#
# = Payload guess
# p_option = sd._SDOption()
# assert(p_option.guess_payload_class(str(p)) == sd.SDOption_IP4_SD_EndPoint)
#
# +SD Option IP6 End Point
# p = sd.SDOption_IP6_EndPoint()
#
# = pkg type & length
# assert(p.type == sd._SDOption.IP6_ENDPOINT_TYPE)
# assert(p.len == sd._SDOption.IP6_ENDPOINT_LEN)
#
# = Payload guess
# p_option = sd._SDOption()
# assert(p_option.guess_payload_class(str(p)) == sd.SDOption_IP6_EndPoint)
#
# +SD Option IP6 Multicast
# p = sd.SDOption_IP6_Multicast()
#
# = pkg type & length
# assert(p.type == sd._SDOption.IP6_MCAST_TYPE)
# assert(p.len == sd._SDOption.IP6_MCAST_LEN)
#
# # Payload guess
# p_option = sd._SDOption()
# assert(p_option.guess_payload_class(str(p)) == sd.SDOption_IP6_Multicast)
#
# +SD OPTION IP6 SD EndPoint
# p = sd.SDOption_IP6_SD_EndPoint()
#
# = pkg type & length
# assert(p.type == sd._SDOption.IP6_SDENDPOINT_TYPE)
# assert(p.len == sd._SDOption.IP6_SDENDPOINT_LEN)
#
# = Payload guess
# p_option = sd._SDOption()
# assert(p_option.guess_payload_class(str(p)) == sd.SDOption_IP6_SD_EndPoint)
#
# + SD Flags
# p = sd.SD()
#
# p.setFlag("REBOOT", 1)
# assert(p.flags == 0x80)
# p.setFlag("REBOOT", 0)
# assert(p.flags == 0x00)
# p.setFlag("UNICAST", 1)
# assert(p.flags == 0x40)
# p.setFlag("UNICAST", 0)
# assert(p.flags == 0x00)
#
# p.setFlag("REBOOT", 1)
# p.setFlag("UNICAST", 1)
# assert(p.flags == 0xc0)
#
# +SD Get Someip Packet
# p_sd = sd.SD()
#
# sd_len = binascii.hexlify(str(p_sd))
#
# p_someip = p_sd.getSomeip()
# assert(len(binascii.hexlify(str(p_someip))) / 2, someip.SOMEIP._OVERALL_LEN_NOPAYLOAD)
#
# p = p_sd.getSomeip(stacked=True)
# assert(len(binascii.hexlify(str(p))) / 2, someip.SOMEIP._OVERALL_LEN_NOPAYLOAD + 12)
#
# + SD
# p = sd.SD()
#
# = length of package without entries nor options
# assert(len(binascii.hexlify(str(p))) / 2 == 12)
#
# = some Entries to array and size check
# p.setEntryArray([sd.SDEntry_Service(), sd.SDEntry_EventGroup()])
# assert(struct.unpack("!L", str(p)[4:8])[0] == 32)
# p.setEntryArray([])
# assert(struct.unpack("!L", str(p)[4:8])[0] == 0)
#
# = some Options to array and size check
# p.setOptionArray([sd.SDOption_IP4_EndPoint(), sd.SDOption_IP4_EndPoint()])
# assert(struct.unpack("!L", str(p)[8:12])[0] == 24)
# p.setOptionArray([])
# assert(struct.unpack("!L", str(p)[8:12])[0] == 0)
#
# = some Entries&Options to array and size check
# p.setEntryArray([sd.SDEntry_Service(), sd.SDEntry_EventGroup()])
# p.setOptionArray([sd.SDOption_IP4_EndPoint(), sd.SDOption_IP4_EndPoint()])
# assert(struct.unpack("!L", str(p)[4:8])[0] == 32)
# assert(struct.unpack("!L", str(p)[40:44])[0] == 24)
#
